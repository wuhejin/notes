java 1995年10月 诞生


一.类加载器ClassLoader
5.1负责加载class文件，class文件在文件开头有特定的文件标识（打开class文件可以看到，开头有cafe babe 咖啡，并且符合jvm规范才加载），将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且，ClassLoader只负责class文件的加载，是否能运行由Execution Engine决定
5.2类加载器有三个或四个：
虚拟机自带的加载器：1.启动类加载器(Bootstrap)C++编写 (JDK自带的class) 2.扩展类加载器(ExtClassLoader) Java (主要是jre/lib/ext包下的类)3.应用程序类加载器(AppClassLoader) (自己编写的)
用户自定义加载器：Java.lang.ClassLoader(抽象类)的子类，用户可以定制类的加载方式


5.3类加载器ClassLoader的双亲委派机制是这样的：
当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，
如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。
5.4保证是沙箱安全（你的代码不能污染源代码，先找到先使用）

二.Execution Engine执行引擎：负责解释命令，提交操作系统执行


三.Native Interface本地接口 Native Method Stack（线程私有）
本地接口的作用是融合不同的编程语言为java所用，于是就在内存中专门开辟了一块区域处理标记为native的代码
具体做法是Native Method Stack 中登记native方法，在Execution Engine 执行时加载native libraries

四.PC寄存器（Program Counter Register）（线程私有）
记录了方法之间的调用和执行情况，指向方法区中的字节码（用来存储指向下一条指令的地址，也就是将要执行的指令代码）
每个线程都有一个程序计数器，是线程私有的（就是给指针），内存很小，几乎忽略不计，不存在垃圾回收；用以完成分支，循环，跳转，异常处理，线程恢复等基础功能

五.方法区（Method Area） （所有内存共享，存在垃圾回收）
虽然JVM规范将方法区描述为堆的一个逻辑部分，但他却还有一个别名叫做Non-Heap（非堆），目的就是和堆分开
·····方法区不是放方法的地方
1.存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool），字段，方法数据，构造函数，普通方法的字节码内容。
2.方法区是规范，在不同虚拟机中里头实现不同，最典型的是永久代（PermGen space，java7以前）和元空间（Meta space，java8以后）
例子：
	List list = new ArrayList();
	方法区 list = new 永久代
	方法区 list = new 元空间
实例变量存在堆内存中，与方法区无关

六.Java栈 （Java stack）（线程私有，不存在垃圾回收）
1.栈也叫栈内存，主管java程序的运行，实在线程创建时创建，它的生命周期随线程的生命期，线程结束，栈内存释放，
2.8种基本类型的变量+对象的引用变量（就是存储对象的地址）+实例方法都是在函数的栈内存中分配
3.栈存储栈帧（栈帧 = java方法）：
	栈帧中存储：本地变量：输入参数和输出参数以及方法内的变量
		   栈操作：记录出战，入栈操作
		   栈帧数据：包括类文件，方法等等
4.StackOverflowError（SOF）（栈溢出）这是错误不是异常
栈管运行，堆管存储

七.heap堆
一个JVM实例只存在一个堆内存，堆内存的大小可以调节，类加载器读取文件后，需把类，方法，常变量放到堆内存中，保存所有引用类型的真实信息以方便执行器执行
堆内存（逻辑上）：
1）新生区（占1/3）：伊甸区（Eden Space），幸存0区（Survivor 0）（from区），幸存1区（Survivor 1）（to区） 比例 8：1：1
新生区参数  ：   调整新生区的大小 -Xmn（一般不调）
2）养老区（占2/3）：
3）永久存储区（java7以前）或元空间（java8）（物理上元空间不在堆，在方法区（使用元空间来实现方法区，相当于元空间就是方法区的一个实现））：

（MGC过程  ： 复制 -> 清空 -> 交换）
1.第一次，当Eden区满，触发第一次GC，把活着的对象复制到SurvivorFrom区，当Eden区再次满，触发GC，则扫描Eden和SurvivorFrom区，对两个区域进行垃圾回收，回收后还活着的对象，复制到SurvivorTo区（如果年龄达到要求（默认15次，-XX:MaxTenuringThreshold 设置对象在新生区的存活次数，java8最大不超过15次），则 复制进养老区）同时活过SurvivorFrom区年龄加1
2.然后，清空Eden和SurvivorFrom区，接下来就是交换，也就是SurvivorTo区变成SurvivorFrom区，SurvivorFrom区变成SurvivorTo区（谁空谁是SurvivorTo区），然后反复如此

jvm进行垃圾回收，对新生区进行垃圾回收（Minor GC）（GC），满了后，在对养老区进行垃圾回收（Full GC）（FGC），都满了后，会抛出异常（OutOfMemoryError）（OOM 堆溢出）

八.永久存储区（元空间）
永久存储区时一个常驻内存区域，用于存放jdk自身所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装在进次区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占用的内存
8.1元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。元空间有注意有两个参数：
MetaspaceSize ：初始化元空间大小，控制发生GC阈值  -Xms
MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存  -Xmx

System.out.println(Runtime.getRuntime().availableProcessors());     获取电脑核数
System.out.println(Runtime.getRuntime().maxMemory());  单位是字节  获取JVM最大使用内存量（默认1/4内存大小）    -Xmx
System.out.println(Runtime.getRuntime().totalMemory());  单位是字节   获取JVM中当前内存总量   -Xms


九.GC回收算法
分代收集算法：1）次数上频繁收集新生区 （复制算法）2）次数上较少收集养老区（标记清除和标记整理混合实现） 3）基本不动元空间
四大算法：
1）引用计数法：每有一个对象引用，就计数加一（缺点：每次都要维护，且计数器本身有消耗，较难处理循环引用）（但JVM的实现一般不用）
2）复制算法（Copying）：新生区中使用，使用GC(就是伊甸区，from区，复制到to区），不会产生内存碎片（缺点：浪费一半内存）
3）标记清除（Mark-Sweep）：（养老区中使用），先标记出要回收的对象，然后统一回收这些对象（优点：不浪费空间）（缺点，会产生内存碎片（空间内存不连续），两次扫描，耗时严重）
4）标记整理：与标记清除一样，多加一步，再次扫描，并往一端移动对象（优点：没有内存碎片）（缺点：需要移动对象的成本，耗时最长）


内存效率：复制算法>标记清除>标记整理
内存整齐度：复制算法=标记整理>标记清除
内存利用率：标记整理=标记清除>复制算法


java9默认垃圾回收器G1：耗时短，没碎片


十.java内存模型（JMM）
volatile在java语言中是一个关键字，用于修饰变量。被volatile修饰的变量后，表示这个变量在不同线程中是共享（实现可见性（保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的））
由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作空间（有些地方为栈空间），工作内存时每个线程的私有数据区域，而Java内存模型（JMM）中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可访问，但线程对变量的操作（读取，赋值等）必须在工作内存中进行，首先将变量从主内存拷贝到线程自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，每个线程的工作内存d都存储着主内存的变量副本拷贝，（所以不同线程之间无法访问对方的工作内存，线程中通信需通过主内存来完成）
1）可见性：每个工作线程都有自己的工作内存，所以当某个线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改。volatile关键字要求被修改之后的变量要求立即更新到主内存，每次使用前从主内存处进行读取。因此volatile可以保证可见性。除了volatile以外，synchronized和final也能实现可见性。synchronized保证unlock之前必须先把变量刷新回主内存。final修饰的字段在构造器中一旦完成初始化，并且构造器没有this逸出，那么其他线程就能看到final字段的值。
2）原子性：在操作系统里面是不可分割的单元。被synchronized关键字或其他锁包裹起来的操作也可以认为是原子的。从一个线程观察另外一个线程的时候，看到的都是一个个原子性的操作。
3）有序性：java的有序性跟线程相关。如果在线程内部观察，会发现当前线程的一切操作都是有序的。如果在线程的外部来观察的话，会发现线程的所有操作都是无序的。因为JMM的工作内存和主内存之间存在延迟，而且java会对一些指令进行重新排序。volatile和synchronized可以保证程序的有序性

